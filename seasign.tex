\documentclass{llncs}

\usepackage{amsmath,amssymb,fullpage}
\usepackage{times}
\usepackage{algorithm,algorithmicx,algpseudocode}

\newcommand{\C}{\mathcal{C}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\Fpbar}{\overline{\mathbb{F}}_p}
\newcommand{\Fqbar}{\overline{\mathbb{F}}_q}
\newcommand{\FF}{\mathcal{F}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\OO}{\mathcal{O}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\ch}{\text{ch}}
\newcommand{\End}{\text{End}}
\newcommand{\Cl}{\text{Cl}}
\newcommand{\seed}{\textsf{seed}}

\renewcommand{\a}{\mathfrak{a}}
\renewcommand{\b}{\mathfrak{b}}
\renewcommand{\c}{\mathfrak{c}}
\renewcommand{\l}{\mathfrak{l}}
\newcommand{\e}{\textbf{e}}
\newcommand{\f}{\textbf{f}}
\newcommand{\x}{\textbf{x}}
\newcommand{\z}{\textbf{z}}

% THEOREM ENVIRONMENTS
%\newtheorem{definition}{Definition}
%\newtheorem{example}{Example}
%\newtheorem{theorem}{Theorem}



\title{SeaSign}

\author{Luca De Feo \and Steven D. Galbraith}
\institute{Mathematics Department, University of Auckland, NZ.
\email{s.galbraith@auckland.ac.nz}}



\date{\today}


\begin{document}
\pagestyle{plain}

\maketitle


\begin{abstract}

\end{abstract}



\section{Intro}

Stolbunov~\cite{Sto12} was the first to give a signature scheme based on isogeny problems.
Due to renewed interest in this problem, especially CSIDH~\cite{CLMPR18} and the scheme by De Feo et al~\cite{DFKS18}.

For $B \in \N$ we use the notation $[-B,B]$ for the set of integers $u$ with $-B \le u \le B$.

\section{Background}

Notation:
\begin{itemize}
\item For an elliptic curve $E$ over a field $K$ we define $\End(E)$ to the the ring of endomorphisms of $E$ defined over the algebraic closure of $K$, and $\End_K(E)$ to be the the ring of endomorphisms defined over $K$.
\item Given two $\OO$-ideals $\a, \b$ we write $\a \cong \b$ if $\a$ and $\b$ are equivalent (meaning that $\a \b^{-1}$ is a principal fractional $\OO$-ideal). 
\end{itemize}


Let $p$ be a prime.
Let $E$ be an ordinary elliptic curve over $\F_p$ with $\End(E) \cong \OO$ or $E$ a supersingular curve over $\F_p$ with $\End_{\F_p}(E) \cong \OO$ where $\OO$ is an order in an imaginary quadratic field.
Let $\Cl(\OO )$ be the ideal class group of $\OO$.
One can define the action of an $\OO$-ideal $\a$ on the curve $E$ as the image curve $E'$ under the isogeny $\phi : E \to E'$ whose kernel is equal to the kernel ideal $E[ \a ] = \{ P \in E( \Fpbar ) : \alpha(P) = 0 \; \forall \alpha \in \a \}$.
We denote $E'$ by $\a * E$.

The set $\{ j(E) \}$ of isomorphism classes of elliptic curves with $\End(E) \cong \OO$ is a principal homogenous space for $\Cl(\OO )$.
General references for all this are Couveignes~\cite{Couv06}
and Stolbunov~\cite{Sto12}.

Given a generic ideal $\a\subset\OO$, the best known algorithm to compute $\a*E$ has subexponential complexity in $\log(\#\Cl(\OO))$~\cite{JS10}.
To make this action efficient one must work instead with ideals $\a = \prod_{i=1}^n \l_i^{e_i}$ where $\l_1, \dots, \l_n$ are prime $\OO$-ideals of small norm $\ell_i$.
Then, the action of $\a$ can be computed as a composition of isogenies of degree $\ell_i$.
Throughout the paper we assume that $\{ \l_1, \dots, \l_n \}$ is a set of non-principal prime ideals in $\OO$, generating $\Cl(\OO)$, of norm polynomial in the size of the class group.
Theoretically we have the bounds $\#\Cl(\OO) = O( \sqrt{p} \log(p) )$ and, assuming a generalised Riemann hypothesis, $\ell_i = O( \log(p)^2 )$.
% NdL: Is #Cl(O) = O(..) really what we want to say? â‰ˆ seems more appropriate
In practice one usually takes $\ell_i=O(\log(p))$ for efficiency reasons; heuristically, this is more than enough to generate the class group.

The basic computational assumption is the ideal action problem:

\begin{definition}\label{defn:ass1}
Given $E$ and $E_A$ to find an ideal $\a$, if it exists, such that $j( E_A ) = j( \a * E )$.
\end{definition}

The best classical algorithms for this problem have exponential time, but there are subexponential-time quantum algorithms for it~\cite{Kup,regev04,childs2014constructing,Kuperberg2013} (Kuperberg, Regev, Childs-Jao-Soukharev, Bonnetain-etc).

Note that this problem admits a random self-reduction: given an instance $(E, E_A)$ one can choose random ideal classes $\b_1, \b_2$ and construct the instance $(E_1, E_2) = (\b_1 * E, \b_2 * E_A )$, which is now uniformly distributed across the set of pairs of isomorphism classes of curves in the isogeny class.
If $\a'$ is a solution to the instance $(E_1, E_2)$ then any ideal equivalent to the fractional ideal $\a'\b_1 \b_2^{-1}$ is a solution to the original instance.

When instantiating the group action in practice, one must choose parameters that make evaluating isogenies of degree $\ell_i$ as efficient as possible.
In the ordinary case, De Feo, Kieffer and Smith~\cite{DFKS18} introduced a method to use the more efficient V\'elu's formulas~\cite{velu71} for some primes $\ell_i$, but were unable to generalize it for sufficiently many.
By using supersingular curves over a field $\F_p$ with $p+1 = 4\prod_{i=1}^n\ell_i$, CSIDH~\cite{CLMPR18} manages to apply V\'elu's formulas to all primes $\ell_i$.
For key exchange, CSIDH samples the exponent vectors $\e = (e_1, \dots, e_n) \in [-B,B]^n \subseteq \Z^n$ for a constant $B$ such that $(2B+1)^n\ge\#\Cl(\OO)\approx p\log p$; this ensures that, heuristically, the key space covers all of $\Cl(\OO)$.

By taking into account the best known attacks, the CSIDH authors propose parameters for the three NIST categories~\cite{NIST2016}, as summarized in Table~\ref{tab:csidh-parms}.
Their implementation of the smallest parameter size CSIDH-1 computes one class group action in under 100ms on a 3.5GHz processor.


\begin{table}
  \centering
  \begin{tabular}{l | r | r | r | r | r | r | r | r}
    & $n$ & $\log_2 p$ & $B$ & NIST level & classical security & quantum security & curve size & exponent size \\
    \hline
    CSIDH-1 &  74 &  500 &  5 & 1 & 125 bits &  61 qbits &  63B &  32B\\
    CSIDH-3 & 131 & 1020 &  7 & 3 & 255 bits &  93 qbits & 128B &  64B\\
    CSIDH-5 & 208 & 1787 & 10 & 5 & 447 bits & 129 qbits & 224B & 115B
  \end{tabular}
  \caption{Proposed parameters for CSIDH~\cite{CLMPR18}.  Effective
    parameters $p$, $n$ and $B$ for CSIDH-3 and CSIDH-5 were not given
    in the paper, and are produced here following their methodology.}
  \label{tab:csidh-parms}
\end{table}



\subsection{Identification protocols and signature schemes}

Do we need to recall the definitions of id-protocols and sig schemes.

There are various transforms to turn an ID protocol into a sig scheme for classical or post-quantum security~\cite{AABN02,DFG13,GCZ16,Katz10,Un15,Un17}.
We focus in this paper on classical adversaries and therefore use the Fiat-Shamir scheme.




\section{Basic Signature Scheme}

Section 2.B of Stolbunov's PhD thesis~\cite{Sto12} contains a sketch of a signature scheme based on isogeny problems (though his decription is not complete and he does not give a proof of security).
It is a Fiat-Shamir scheme based on an identification protocol.
Section 4 of Couveignes~\cite{Couv06} also sketches the identification protocol, but does not mention that it can be converted to a signature scheme.


The public key consists of $E$ and $E_A = \a * E$, where $\a = \prod_{i=1}^n \l_i^{e_i}$ is the private key.
To construct the private key one uniformly chooses an exponent vector $\e = (e_1, \dots, e_n) \in [-B,B]^n \subseteq \Z^n$ for some suitably chosen constant $B$.

In the identification protocol the prover generates $t$ random ideals $\b_k = \prod_{i=1}^n \l_i^{f_{k,i}}$ for $1 \le k \le t$ and computes $E_k = \b_k * E$.
Here the exponent vectors $\f_k = ( f_{k,1}, \dots, f_{k,n} )$ are uniformly and independently sampled in $[-B,B]^n$.
The prover sends $(j( E_k ) : 1 \le k \le t )$ to the verifier.
The verifier responds with $t$ uniformly chosen challenge bits $b_1, \dots, b_t \in \{0,1\}$.
If $b_k = 0$ the prover responds with $\f_k = ( f_{k,1}, \dots, f_{k,n} )$ and the verifier checks that $j(E_k) = j( (\prod_{i=1}^n \l_i^{f_{k,i}}) * E )$.
If $b_k = 1$ the prover responds with a representation of $\b_k \a^{-1}$. Stolbunov notes that sending the vector $\f_k - \e = (f_{k,i} - e_k )$ would not be secure as it would leak the private key; but neither he nor Couveignes explains how to prevent this leakage.
When $b_k=1$ the verifier checks that $j(E_k) = j( (\b_k \a^{-1}) * E_A )$.

To obtain a signature scheme one applies the Fiat-Shamir transform, and hence obtains the challenge bits $b_k$ as the hash value $H( j(E_1), \dots, j(E_t) , m )$ where $H$ is a cryptographic hash function with $t$-bit output and $m$ is the message to be signed.
The signature consists of the binary string $b_1\cdots b_t$ and the representations of the ideal classes $\b_k$ when $b_k = 0$ and $\b_k \a^{-1}$ when $b_k = 1$.

The verifier computes, for $1 \le k \le t$, $E_k = \b_k * E$ when $b_k = 0$ and $E_k = \b_k \a^{-1} * E_A$ when $b_k = 1$. The verifier then computes $H( j( E_1), \dots, j(E_t), m )$ and checks whether this is equal to the binary string $b_1\cdots b_t$, and accepts the signature if and only if the strings agree.





In this paper we propose two solutions to the problem of representing $\b_k \a^{-1}$ without leaking the private key.
Our main solution uses ideas from lattice cryptography and we describe this in the remainder of the section.
An alternative solution requires knowledge of a relation lattice in the ideal class group, which can be computed efficiently using a quantum computer. We describe this alternative solution in an appendix.


\subsection{Using rejection sampling}\label{sec:sig-reject-sample}

% The approach in Section~\ref{sec:sig-relation-lattice} is theoretically elegant, but the assumption that the relation lattice $L$ can be computed is doubtful for practical post-quantum signatures.
%Hence this section contains our main solution to the problem of representing the ideal class $\b_k \a^{-1}$.
The idea is to use rejection sampling in exactly the way proposed by Lyubashevsky~\cite{Lyu09} in the context of lattice signatures.

Let $B > 0$ be a constant. When generating the private key we sample uniformly $e_i \in [-B, B]$ for $1 \le i \le n$. Let $\e = ( e_1, \dots, e_n )$.
The value $B$ is presumably chosen large enough that $\prod_{i=1}^n \l_i^{e_i}$ covers most ideal classes and so that the output distribution is close to uniformly distributed in $\Cl(\OO)$, but we try to avoid any explicit requirement or assumption that this distribution is uniform.

The idea is to sample the exponents $f_{k,i}$ uniformly in $[-(nt+1)B, (nt+1)B]$, where $t$ is the number of parallel rounds of the identification protocol and $n$ is the number of primes.
Let $\f_k = (f_{k,1}, \dots, f_{k,n} )$.
It is certainly the case that $\b_k = \prod_{i=1}^n \l_i^{f_{k,i}}$ is likely to be close to uniformly distributed, but we shouldn't need to make any assumption about it.

If the $k$-th challenge bit $b_k$ is zero then the prover responds with $\f_k = ( f_{k,1}, \dots, f_{k,n} )$ and the verifier checks that $j(E_k) = j( (\prod_{i=1}^n \l_i^{f_{k,i}}) * E )$ as in the basic scheme above.\footnote{In the scheme and analysis I actually apply rejection sampling to the case $b_k = 0$. It doesn't really matter one way or the other.}
If $b_k = 1$ then the prover is required to provide a representation of $\b_k \a^{-1}$, the idea is to compute the vector $\z_k = (z_{k,1}, \dots, z_{k,n}) $ defined by $z_{k,i} = f_{k,i} - e_i $ for $1 \le i \le n$.
As already noted, outputting $\z$ directly would potentially leak the secret.
To prevent this leakage we only output $\z_k$ if all its entries satisfy $| z_{k,i} | \le nt B$.
We give the signature scheme in Figure~\ref{fig:sig-scheme}.
It remains to show that in the accepting case the vector leaks no information about the private key, and that the rejecting case occurs with low probability. We do this in the following two lemmas.

\begin{lemma} \label{lem:sim2}
The distribution of vectors $\z_k$ output by the signing algorithm is the uniform distribution and therefore is independent of the private key $\e$.
\end{lemma}

\begin{proof}
Let $U = [-(nt+1)B, (nt+1)B]$. Then $\#U = 2(nt + 1)B + 1$.
If $e \in [-B, B]$ then 
\[
    [-ntB, ntB] \subseteq  U - e = \{ f - e : f \in U \} \subseteq [-(nt+2)B, (nt+2)B ].
\]
Hence, when rejection sampling (only outputting values $f_{k,i} - e_i$ in the range $[-ntB, ntB]$) is applied then the output distribution of $\z_k$ is the uniform distribution $[-ntB, ntB]^n$.
This argument does not depend on the choice of $\e$, so the output distribution is independent of $\e$.
\end{proof}



\begin{lemma}
The probability that the signing algorithm does not output $\bot$ is at least $1/e > 1/3$.
\end{lemma}

\begin{proof}
Let notation be as in the proof of Lemma~\ref{lem:sim2}.
For fixed $e \in [-B, B]$ and uniformly sampled $f \in U$, the probability that a value $f-e$ lies in $[-ntB, ntB]$ is
\[
   \frac{2ntB + 1}{2(nt+1)B + 1}  = 1 - \frac{2B}{2(nt+1)B + 1} \ge 1 - \frac{1}{nt+1}.
\]
Hence, the probability that all of the values $z_{k,i}$ over $1 \le k \le t, 1 \le i \le n$ lie in $[-ntB, ntB]$ is at least $(1 - 1/(nt+1))^{nt}$.
Using the inequality $1 - 1/(nt+1) \ge e^{-1/nt}$ for $nt \ge 1$ it follows that the probability that all values are in the desired range is at least
\[
   \left( e^{-1/nt} \right)^{nt} = e^{-1}.
\]
This completes the proof.
\end{proof}


We can therefore get a rough idea of parameters and efficiency for the scheme.
For security we need a large enough set of private keys. So we need $(2B+1)^n$ large enough.
We need $t$ at least 128 so that an attacker cannot guess the hash value or invert the hash function.
The vectors $\z_k$ have entries of size bounded by $ntB$, which means that for each $k$ and each prime $\l_i$ one needs to compute up to $ntB$ isogenies of degree $\ell_i$.
This means that the total number of isogeny computations is upper bounded by $(nt)^2 B$.
The quadratic dependence on $nt$ is going to be a big pain in practice.
For example, taking $t=128, n = 50, B = 6$ gives around $2^{27}$ isogeny computations in verification!
We can make $t$ small using the techniques in later sections, but one needs $n$ large unless $B$ is going to get very large. So even going down to $t=8$ still has signatures requiring around $2^{20}$ isogeny computations.

It might be worth to consider different shaped boxes (i.e., favouring smaller prime isogeny degrees) like done by Stolbunov. But it won't bypass the $nt$ issue

%\begin{figure} 



%If a challenge bit $b_k = 1$ and the prover is required to provide a representation of $\b_k \a^{-1}$, the idea is to compute the vector $\z = (z_1, \dots, z_n) $ so that $z_k = f_{k,i} - e_k $.
%Now, if all $|z_k| \le tB$ then we accept $\z$ as a ``safe'' representation of the ideal, otherwise we reject $\z$ and the protocol fails.
%
%f $E$ and $E_A = \a * E$, where $\a = $ is the private key.
%To construct the private key one unif
%
% $1 \le k \le t$ and computes $E_k = \b_k * E$.
%Here the exponent vectors $\f_k = ( f_{k,1}, \dots, f_{k,n} )$ are uniformly and independently sampled in $[-B,B]^n$.

\begin{algorithm}[H]
	\caption{KeyGen \label{alg:KeyGen}}
	\textbf{Input:} $B$, $\l_1, \dots. \l_n$, $E$

	\textbf{Output:} $sk =\e$ and $pk = E_A$

	\begin{algorithmic}[1]
		\State $\e \leftarrow [-B,B]^n$ 
		\State $E_A = ( \prod_{i=1}^n \l_i^{e_i} ) * E$
		\State \Return $sk= \e$, $pk = E_A$
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
	\caption{Sign \label{alg:Sign}}
	\textbf{Input:} $m$, $(E,E_A)$, $\e$
	\textbf{Output:} $(\z_1, \dots, \z_t)$, $(b_1 , \dots, b_t)$
	\begin{algorithmic}[1]
		\For {$k=1 , \dots , t$}
		\State $\f_k \leftarrow [-(t+1)B,(t+1)B]^n$ 
		\State $E_k = ( \prod_{i=1}^n \l_i^{f_{k,i}} ) * E$
		\EndFor
		\State $b_1 \Vert \cdots \Vert b_t = H( j(E_1) , \dots, j(E_t), m )$
		\For {$k=1, \dots, t$}
		\If{$b_k=0$}
		\State $\z_k = \f_k$
		\Else
		\State $\z_k = \f_k - \e$
		\EndIf
		\If{$\z_{k} \not\in [-tB,tB]^n$} \State \Return $\bot$ \EndIf
		\EndFor
		\State \Return $\sigma = (\z_1, \dots, \z_t, b_1 , \dots, b_t)$
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
	\caption{Verify \label{alg:Verify}}
	\textbf{Input:} $m$, $(E,E_A)$, $\sigma$

	\textbf{Output:} Valid/Invalid

	\begin{algorithmic}[1]
		\State Parse $\sigma$ as $(\z_1, \dots, \z_t, b_1 , \dots, b_t)$
		\For {$k=1 , \dots , t$}
		\If{$b_k=0$}
		\State $E_k = ( \prod_{i=1}^n \l_i^{z_{k,i}} ) * E$
		\Else
		\State $E_k = ( \prod_{i=1}^n \l_i^{z_{k,i}} ) * E_A$
		\EndIf
		\EndFor
		\State $b_1' \Vert \cdots \Vert b_t' = H( j(E_1) , \dots, j(E_t), m )$
		\If{$(b_1', \dots, b_t') = (b_1 , \dots, b_t)$} \State \Return Valid
		\Else \State \Return Invalid \EndIf
	\end{algorithmic}
\end{algorithm}

%\end{figure}




\subsection{Security proof}
\label{sec:security-proof}

We now prove security of the basic scheme in the random oracle model against a classical adversary. 
%The proof covers both cases.
The proof technique is the standard approach that uses the forking lemma.


\begin{definition} \label{defn:ass1p}
Let notation be as in the key generation protocol of the scheme.
Given $(E, E_A)$, where $E_A = \a * E$ for some ideal $\a = \prod_{i=1}^n \l_i^{e_i}$ and the exponent vector $\e = (e_1, \dots, e_n)$ is uniformly sampled in $[-B,B]^n \subseteq \Z^n$, to compute any ideal equivalent to $\a$.
\end{definition}

Depending on how close to uniform is the output of the public key generation, this problem may or may not be equivalent to Definition~\ref{defn:ass1} and may or may not have a random self-reduction.
Since understanding the distributions is non-trivial, we do not consider such issues further in this paper.


\begin{theorem}\label{thm:security}
In the random oracle model, the basic signature scheme is unforgeable under a chosen message attack under the assumption of Definition~\ref{defn:ass1p}.
\end{theorem}

\begin{proof}
Consider a polynomial-time adversary $A$ against the signature scheme. So $A$ takes a public key, makes queries to the hash function $H$ and the signing oracle, and outputs a forgery of a signature for the public key.

Let $(E, E_A = \a * E )$ be an instance of Definition~\ref{defn:ass1p}.
We assume that $\#\Cl(\OO) \ge \sqrt{p}$.
Run the adversary $A$ with public key $(E, E_A)$.
% (or apply the random self-reduction mentioned earlier) in the random oracle model.

Suppose the adversary $A$ makes at most $Q$ (polynomial in the security parameter) queries in total to either the random oracle $H$ or the signing oracle. We now explain how the simulator responds to these queries. The simulator maintains a list, initially empty, of pairs $(x, H(x))$ for each value of the random oracle that has been defined.

\noindent \textbf{Sign queries:}
To answer a Sign query on message $m$ the simulator chooses 
$t$ uniformly chosen bits $b_1, \dots, b_t \in \{0,1\}$.
When $b_k = 0$ the simulator chooses a random ideal $\b_k = \prod_{i=1}^n \l_i^{f_{k,i}}$ as in the real protocol and computes $E_k = \b_k * E$.
When $b_k = 1$ the simulator chooses a random representation of an ideal $\c_k$ (consistent with the protocol under consideration; so using Lemma~\ref{lem:sim2}) and computes $E_k = \c_k * E_A$.
We define $H( j( E_1), \dots, j(E_t), m ) := b_1 \cdots b_t$, unless the random oracle has already been defined on this input in which case we output $\perp$.
((*****)) NEED TO WORK ON THIS ((****))
The probability of failure is at most $Q/\sqrt{p}^t$, since the values $j(E)$ are uniformly and independently sampled by the simulator from $\Cl(\OO)$, which has size at least $\sqrt{p}$.
Note that $Q/\sqrt{p}^t$is negligible since $p$ is exponential in the security parameter and $Q$ is polynomial.
Assuming the simulation does not fail, the output is a valid signature and is indistinguishable from signatures output by the real scheme in the random oracle model and assuming the statistical distances in Lemma~\ref{lem:sim1} or Lemma~\ref{lem:sim2} are negligible.

\noindent \textbf{Hash queries:}
To answer a random oracle query on input $x$ one checks if $(x,y)$ already appears in the list, and if so returns $y$. Otherwise one chooses uniformly at random $y \in \{0,1\}^t$ and sets $H(x) := y$ and adds $(x,y)$ to the list.

Eventually $A$ outputs a forgery $(m, b_1\cdots b_t, \c_1, \dots, \c_t)$ that passes the verification equation.
The proof now invokes the Forking Lemma. The adversary is replayed with the same random tape and the exact same simulation, except that one of the hash queries is answered with a different binary string.
With non-neglible probability the adversary outputs a forgery with the same message $m$ and the same input $(j(E_1), \dots, j(E_t), m)$ to $H$, but a different output string $b_1'\cdots b_t'$. Let $k$ be an index such that $b_k \ne b_k'$ (without loss of generality $b_k = 0$ and $b_k' = 1$). Then the ideal classes $\c_k$ and $\c_k'$ in the two signatures are such that $j( \c_k * E ) = j( \c_k' * E_A )$ and so $\c_k' \c_k^{-1}$ is a solution to the problem instance.
\end{proof}

Due to the forking lemma, this proof is not tight. We could give an exact formula for the success probability of the reduction.



\section{Smaller sigs}


The signature size of the basic scheme is very large, since the sigma protocol that underlies the identification scheme only has single bit challenges. 
In practice we need $t \ge 128$, which means signatures are very large.
To get shorter signatures it is natural to try to increase the size of the challenges.
In this section we sketch an approach to obtain larger sets of challenge values, by trading the challenge size with the public key size. In the next section we explain how to shorten the public keys again.


The basic idea is to have public keys $( E_{A,1} = \a_1 * E , \dots , E_{A,2^s} = \a_{2^s} * E )$.
In the identification protocol one chooses $t$ random ideals $\b_k = \prod_{i=1}^n \l_i^{f_{k,i}}$ and computes $E_k = \b_k * E$.
Now the verifier responds with $t$ uniformly chosen challenges $b_1, \dots, b_t \in \{1, 2, \dots, 2^s \}$.
For each $k$ the prover responds with a representation $\c_k$ of the ideal class $\a_{b_k} \b_k^{-1}$ and the verifier can check that $j( E_k ) = j( \c_k * E_{A, b_k})$.

For security we now only require $ts \ge 128$. Taking, say, $s = 16$ can mean $t$ as low as 8, and so only 8 ideal classes need to be transmitted as part of the signature.
Of course the public key now includes $2^{16}$ $j$-invariants (elements of $\F_p$) which would be around 4 megabytes.

Again the signature comes in two flavours: first scheme uses the relation lattice in the class group, assuming this can be computed; second scheme uses rejection sampling.
The signature size in the latter case would be.....

\subsection{Security proof}

When we apply the forking lemma we now find there is some index $k$ with $b_k \ne b_k'$.
Hence have have ideal classes $\c_k$ and $\c_k'$ such that $j( \c_k * E_{A, b_k} ) = j( \c_k' * E_{A, b_k'})$. It follows that $\c_k' \c_k^{-1}$ is an ideal class corresponding to an isogeny $E_{A,b_k} \to E_{A,b_k'}$.
Hence the computational assumption underlying the scheme is:
Given $(E_{A,1}, \dots, E_{A,2^s} )$ to find an isogeny between any pair of the elliptic curves.
If this assumption is hard then one can immediately apply Theorem~\ref{thm:security} to obtain a secure signature scheme.

Since this assumption seems a bit un-natural, we show how to give a signature scheme based on some more natural problems.

Version 1: We can reduce to the standard problem of Definition~\ref{defn:ass1} with a extra $1/2$ factor in the success probability (which is not a big issue since the security proof isn't tight anyway).
Let $(E, E_A = \a * E )$ be an instance of Definition~\ref{defn:ass1}. Choose random ideal classes $\b_1, \dots, \b_{2^s}$ and compute $E_k = \b_k * E$ for $1 \le k \le 2^{s-1}$ and $E_k = \b_k * E_A$ for $2^{s-1} < k \le 2^s$. Choose a random permutation $\pi$ on $\{ 1, 2, \dots, 2^s \}$ and set the public key to be the sequence $E_{A,k} = E_{\pi(k)}$.
Note that these curves are all uniformly sampled in the isogeny class, and so there is no way to distinguish whether the curve has been generated from $E$ or $E_A$.
When the forking lemma is applied we have, for some index $k$, two different ideals $\c_k, \c_k'$ such that $j( \c_k * E_{A, b_k} ) = j( \c_k' * E_{A, b_k'})$.
With probability $1/2$ we have that one of the $E_{A,b_k}$ is known to the simulator as  $\b * E$ and the other is known as $\b' * E_A$. If this event occurs then one solves the original instance as $\b' \b^{-1}$.

Version 2: Have a computational assumption $(E, \a * E, \a^2 * E, \a^3 * E , \dots, a^{2^s - 1} * E )$ and 3-special soundness implies can get $\a$ with a good probability. This is cute but ultimately pointless.


\subsection{Reducing storage for private keys}

Rather than storing all the private keys $\a_i$ one could have generated them using a pseudorandom generator as $PRG( \seed, i )$ where $\seed$ is a seed and $i$ is used to generate the $i$-th private key (which is an integer exponent vector).
The prover only needs to store $\seed$ and can then recompute the private keys as needed.
Of course, during key generation one needs to compute all the public keys, but during signing one only needs to determine $t \approx 8$ private keys.





\section{Smaller public keys}

Use a Merkle tree to compress the public key.
Public key is now just a hash value.

Signature increases to have 


\begin{table}
  \centering
  \begin{tabular}{l | c | c | c | c |}
    & Basic scheme
    & Rejection sampling
    & Parallel proof
    & Compressed keys\\
    \hline
    \hspace{1em}\textbf{Exact} &&&&\\
    Sig size
    & $\lambda\lceil n\log (2B+1)\rceil + \lambda$
    & $\lambda\lceil n\log (2n\lambda B + 1)\rceil + \lambda$
    & $\frac{\lambda}{s}\lceil n\log (2n\frac{\lambda}{s}B + 1)\rceil + \lambda$
    & $\frac{\lambda}{s}(\lceil n\log (2n\frac{\lambda}{s}B + 1)\rceil + \log p) + (s+1)\lambda$\\
    PK size
    & $\log p$ & $\log p$ & $2^s\log p$ & $\lambda$ \\
    SK size
    & $n\log(2B+1)$ & $n\log(2B+1)$ & $2^s n\log(2B+1)$ & $(2^s+1) \lambda$\\
    $\Cl(\OO)$ actions &&&&\\
    $\to$ keygen
    & 1 & 1 & $2^s$ & $2^s$\\
    $\to$ sig/verify
    & $\lambda$ & $n\lambda^2$ & $n(\lambda/s)^2$ & $n(\lambda/s)^2$\\
    \hline
    \hspace{1em}\textbf{Asymptotic} &&&&\\
    Sig size
    & $O(\lambda^3)$ & $O(\lambda^3)$ & $O(\lambda^3/s)$ & $O(\lambda^3/s)$\\
    PK size
    & $2\lambda^2$ & $2\lambda^2$ & $2^{s+1}\lambda^2$ & $\lambda$\\
    SK size
    & $\lambda^2$ & $\lambda^2$ & $2^s\lambda^2$ & $(2^s+1)\lambda$\\
    $\Cl(\OO)$ actions &&&&\\
    $\to$ keygen
    & 1 & 1 & $2^s$ & $2^s$\\
    $\to$ sig/verify
    & $\lambda$ & $\lambda^4/\log(\lambda)$
    & $(\lambda^2/s)^2/\log(\lambda)$ & $(\lambda^2/s)^2/\log(\lambda)$\\
    \hline
    \hspace{1em}\textbf{CSIDH(128,16)} &&&&\\
    Sig size
    & 4112 B & 19600 B & 944 B & 1209 B\\
    PK size
    & 63 B & 63 B & 4032 KB & 16 B\\
    SK size
    & 32 B & 32 B & 2048 KB & 1024.02 KB \\
    Est. sig/verify time
    & 13 s & 122000 s & 474 s & 474 s\\
    Est. keygen time
    & 0.1 s & 0.1 s & 6554 s & 6554 s
  \end{tabular}
  \caption{Parameter size and performance of the various signature
    protocols.
    Equivalences used for asymptotic analysis are:
    $\log p \sim 2\lambda^2$, $n\log B\sim \lambda^2$,
    $n\log n \sim 2\lambda^2$.
    All logarithms are in base 2. % NdL: this is probably wrong
  }
  \label{tab:comparison}
\end{table}

\bibliographystyle{plain}
\bibliography{biblio}



\appendix



\section{Using the relation lattice}\label{sec:sig-relation-lattice}

This section explains a solution to the problem of representing an ideal class without leaking the private key of the signature scheme.

Let $\{ \l_1, \dots, \l_n \}$ be a set of $\OO$-ideals that generates $\Cl( \OO )$.
Define $L = \{ (x_1, \dots, x_n ) \in \Z^n : \prod_{i=1}^n \l_i^{x_i} \cong (1) \}$.
Then $L$ is a rank $n$ lattice with volume equal to $\#\Cl(\OO)$.
We call this the \emph{relation lattice}.

A basis for this lattice can be constructed in subexponential time using classical algorithms~\cite{hafner1989rigorous,biasse_fieker_jacobson_2016} or in probabilistic polynomial time using quantum algorithms (define $f:\Z^n\to\Cl(\OO)$ by $f(x_1,\dots,x_n)=\prod_{i=1}^n\l_i^{x_i}$, then $f$ can be evaluated in polynomial time~\cite{shanks1989gauss,Cohen1993}, and finding a basis for $L=\ker f$ is an instance of the Hidden Subgroup Problem for $\Z^n$, which can be solved in polynomial time using Kitaev's generalization of Shor's algorithm~\cite{kitaev1995hsp}).
The classical approach is not very interesting since the underlying computational assumption is only subexponentially hard for quantum computers, but it might make sense in a certain setting.
The quantum case would make sense in a post-quantum world where a quantum computer can be used to set up the system parameters for the system and then is not required for further use.
It might also be possible to construct $(E, p )$ such that computing the relation lattice is efficent (e.g., constructing $E$ so that $\Cl( \End(E))$ has smooth order), but we do not consider such approaches in this paper.

For the remainder of this section we assume that the relation lattice is known.
Let $\{ \x_1, \dots, \x_n \}$ be a basis for $L$
Let $\FF = \{ \sum_{i=1}^n : u_i \x_i : -1/2 \le u_i < 1/2 \}$ be the centered fundamental domain of the basis of $L$.
Then there is a one-to-one correspondence between $\FF \cap \Z^n$ and $\Cl(\OO)$ by
$(z_1, \dots, z_n ) \in \FF \cap \Z^n  \mapsto \prod_{i=1}^n \l_i^{z_i}$.
In practice one prefers a basis for $L$ so that all vectors in $\FF$ have relatively short norm, which is achieved by taking the basis to be as short and close to orthogonal as possible. Hence one applies lattice basis reduction to obtain as ``nice'' a basis for $L$ as possible.

Note that, given a basis $\{ \x_1, \dots, \x_n \}$ for $L$ and a vector $\z = (z_1, \dots, z_n ) \in \Z^n$ one can efficiently compute the unique vector in $\FF \cap (\z + L )$ using the Babai rounding method~\cite{Bab86}.



Returning to Stolbunov's signature scheme, the solution to the problem is then straightforward:
Given $\a = \prod_{i=1}^n \l_i^{e_i}$ and $\b_k = \prod_{i=1}^n \l_i^{f_{k,i}}$,
a representation of $\b_k \a^{-1}$ is obtained by computing the vector $\z' = \f_k - \e = (f_{k,i} - e_k)$
and then using Babai rounding to get the unique vector $\z$ in $\FF \cap (\z' + L )$.
The vector $\z$ is sent as the response to the $k$-th challenge.
Since $\b_k$ is a uniformly chosen ideal class, the class $\b_k \a^{-1}$ is also uniformly distributed as an ideal class, and hence the vector $\z \in \FF \cap \Z^n$ is uniformly distributed and carries no information about the private key.

\begin{lemma}
If $\b_k$ is a uniformly chosen ideal class then the vector 
$\z \in \FF \cap \Z^n$ corresponding to $\f_k - \e$ is uniformly distributed.
\end{lemma}

\begin{proof}
For fixed $\e$ the vector $\z$ depends only on the ideal class of $\b_k$.
But $\b_k$ is uniform and independent of $\e$ and not known to verifier.
\end{proof}



If the basis for $L$ is sufficiently nice then one can obtain good bounds on the size of the vectors $\z$.

One final remark: In the security proof we need to be able to simulate the signing oracle, and hence we need to produce uniformly chosen vectors $\z \in \FF \cap \Z^n$.
The simplest way to do this is to uniformly sample $\z'$ in a large box in $\Z^n$ and then apply Babai rounding as above.
Proving anything about this seems to be hard: How large is the box? How close to uniform?
This ended up in the ``too hard'' pile.


\begin{lemma} \label{lem:sim1}
Let $B \in \N$. Let $D_1$ be the distribution on ideal classes obtained by computing $\prod_{i=1}^n \l_i^{x_i}$ over uniformly sampled $x_i \in [-B,B]$.
Suppose the statistical distance between $D_1$ and the uniform distribution on $\Cl(\OO)$ is bounded by $\epsilon$.
Let $D_2$ be the distribution on $\FF \cap \Z^n$ defined by uniformly sampling vectors $\x \in [-B,B]^n$ and applying Babai rounding.
Let $U$ be the uniform distribution on $\FF \cap \Z^n$.
Then the statistical distance between $D_2$ and $U$ is at most $\epsilon$.
\end{lemma}

Note $[-B,B]$ is the set of integers $u$ with $-B \le u \le B$.


\begin{proof}
They are the same thing.
\end{proof}



\end{document}





